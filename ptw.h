// Copyright 2015, University of North Carolina
// Authors: Kevin Snow, Nathan Otterness
//
// This file provides the interface to ptw.o, a library intended to be used for
// breaking WEP's use of RC4, as described in the paper "Breaking 104 bit WEP
// in less than 60 seconds"
#ifndef _PTW_H
#define _PTW_H

#include <stdio.h>
#include <stdint.h>
#include <vector>
#include <string>
#include <set>

using std::string;
using std::set;
using std::vector;

// Stores an A_i approximation and the number of votes for it
typedef struct {
  uint8_t approximation;
  uint16_t votes;
} PTWEntry;
typedef set<uint32_t> IvSet;
typedef vector<PTWEntry> PTWEntryList;
typedef vector<PTWEntryList> PTWTable;

// 802.11 Packet Header
typedef struct {
  uint8_t frame_control_1;
  uint8_t frame_control_2;
  uint16_t duration;
  uint8_t address_1[6];
  uint8_t address_2[6];
  uint8_t address_3[6];
  uint16_t seq;
} WifiHeader;

// WEP Packet Header
typedef struct {
  // 24 bit initialization vector
  uint8_t iv[3];
  // The last 2 bits indicate which of the 4 keys is being used.
  uint8_t key_id;
} WepHeader;

class Ptw {
 public:
  Ptw() {}

  // Initialize the table to store approximations
  void Initialize(size_t iv_size, size_t key_size);

  // Processes the named pcap file.
  void ProcessNetworkTrace(const string& filename);

  // Given an IV, plaintext, and ciphertext, compute approximations for each
  // key byte
  virtual void UpdateApproximation(const uint8_t* iv, const uint8_t* plaintext,
    const uint8_t* ciphertext, size_t text_size);

  // Called after all approximations have been made for each key byte. Use the
  // approximation results to search for the key in a smart way.
  // Hint: first sort approximations for each key byte, then do a search
  // Returns an empty string or the guessed key
  virtual string Search() = 0;

 protected:
  // Processes a single WEP packet.
  void HandleWepPacket(const WifiHeader* wifi_header,
    const WepHeader* wep_header, const uint8_t* payload,
    size_t payload_size, const uint8_t* icv);

  // Uses the stored IV and keystream to test the given WEP key
  bool TestKey(const uint8_t wep_key[]);

  // Test if we have seen this IV before
  bool CheckAndLogIv(const uint8_t iv[]);

  // Print the given byte array in hex notation
  void PrintBytes(const uint8_t* bytes, int len);
  void PrintVector(std::vector<uint8_t> &v);

  // Print the PTW Table
  void PrintPtwTable();

  void KeyFromApproximations(uint8_t * approximations, uint8_t *key);
  void KeyFromApproximationIndices(std::vector<uint8_t> &v, uint8_t *key);

  // Member variables
  IvSet ivs_seen_;  // Set of IV's already seen, dont double count
  int iv_size_;     // How many bytes an IV is, typically 3
  int key_size_;    // How many bytes the WEP key is, 5 or 13
  string test_iv_;  // A sample IV
  string test_keystream_;  // The keystream generated by testIv+WEP_KEY
  PTWTable ptw_table_;  // The table storing PTW approximations (A_i's)
};

#endif
